import fs from "fs";
import path from "path";
import sharp from "sharp";
import { PDFDocument, rgb, PDFFont, PDFPage } from "pdf-lib";
import { createRequire } from "module";

const require = createRequire(import.meta.url);
const fontkit = require("fontkit");

const BRAND = {
  bg: rgb(0xff / 255, 0xf7 / 255, 0xfb / 255),
  primary: rgb(0, 0, 0),
  accent: rgb(0xf5 / 255, 0x72 / 255, 0x0d / 255), // orange
  accent2: rgb(0xaa / 255, 0x02 / 255, 0x54 / 255), // pink
  muted: rgb(0x6b / 255, 0x72 / 255, 0x80 / 255),
  white: rgb(1, 1, 1),
};

const A4: [number, number] = [595.28, 841.89];
const M = { top: 56, bottom: 48, left: 48, right: 48 };

const H1 = 20;
const H2 = 12;
const BODY = 10;
const LH = (s: number) => s * 1.35;

function safe(v: unknown) {
  return (typeof v === "string" ? v : "") || "";
}

async function readPublic(relPath: string): Promise<Uint8Array> {
  const abs = path.join(process.cwd(), "public", relPath);
  return await fs.promises.readFile(abs);
}

function wrapText(text: string, maxWidth: number, font: any, fontSize: number) {
  const t = (text || "—").replace(/\s+/g, " ").trim();
  const words = t ? t.split(" ") : ["—"];
  const lines: string[] = [];
  let line = "";

  for (const w of words) {
    const test = line ? `${line} ${w}` : w;
    const width = font.widthOfTextAtSize(test, fontSize);
    if (width <= maxWidth) line = test;
    else {
      if (line) lines.push(line);
      line = w;
    }
  }

  if (line) lines.push(line);
  return lines.length ? lines : ["—"];
}

function isHttpUrl(s: string) {
  return /^https?:\/\//i.test(s);
}

async function loadImageBytes(src: string): Promise<Uint8Array | null> {
  const s = (src || "").trim();
  if (!s) return null;

  try {
    if (isHttpUrl(s)) {
      const res = await fetch(s);
      if (!res.ok) return null;
      const ab = await res.arrayBuffer();
      return new Uint8Array(ab);
    }

    const rel = s.startsWith("/") ? s.slice(1) : s;
    const bytes = await readPublic(rel);
    return new Uint8Array(bytes);
  } catch {
    return null;
  }
}

function normalizeDateString(dateStr: string): string {
  const d = new Date(dateStr);
  if (isNaN(d.getTime())) return dateStr;
  const day = String(d.getDate()).padStart(2, "0");
  const month = String(d.getMonth() + 1).padStart(2, "0");
  const year = d.getFullYear();
  return `${day}/${month}/${year}`;
}

async function normalizeToJpeg(bytes: Uint8Array): Promise<Uint8Array | null> {
  try {
    const fixed = await sharp(bytes).rotate().jpeg({ quality: 88 }).toBuffer();
    return fixed?.length ? new Uint8Array(fixed) : null;
  } catch {
    return null;
  }
}

function drawHeader(opts: {
  page: PDFPage;
  width: number;
  height: number;
  fontBold: PDFFont;
}) {
  const { page, width, height, fontBold } = opts;

  // Header band (2 rectangles)
  page.drawRectangle({ x: 0, y: height - 92, width, height: 92, color: BRAND.accent });
  page.drawRectangle({
    x: width * 0.55,
    y: height - 92,
    width: width * 0.45,
    height: 92,
    color: BRAND.accent2,
  });

  page.drawText("CASTPOINT", {
    x: M.left,
    y: height - 54,
    size: 18,
    font: fontBold,
    color: BRAND.white,
  });

  page.drawText("Profile", {
    x: M.left,
    y: height - 74,
    size: 16,
    font: fontBold,
    color: BRAND.white,
  });
}

function drawFooter(opts: { page: PDFPage; fontRegular: PDFFont }) {
  const { page, fontRegular } = opts;
  page.drawText("Generated by CASTPOINT platform", {
    x: M.left,
    y: M.bottom - 18,
    size: 8,
    font: fontRegular,
    color: BRAND.muted,
  });
}

function drawSectionTitle(page: PDFPage, title: string, x: number, y: number, font: PDFFont) {
  page.drawText(title, { x, y, size: H2, font, color: BRAND.accent2 });
  return y - 16;
}

function drawWrappedBlock(opts: {
  page: PDFPage;
  text: string;
  x: number;
  y: number;
  width: number;
  font: PDFFont;
  fontSize: number;
  maxLines?: number;
  lineHeight?: number;
  color?: any;
}) {
  const {
    page,
    text,
    x,
    y,
    width,
    font,
    fontSize,
    maxLines = 9999,
    lineHeight = LH(fontSize),
    color = BRAND.primary,
  } = opts;

  const lines = wrapText(text || "—", width, font, fontSize).slice(0, maxLines);
  let yy = y;
  for (const ln of lines) {
    page.drawText(ln, { x, y: yy, size: fontSize, font, color });
    yy -= lineHeight;
  }
  return yy;
}

function splitBullets(text: string) {
  const t = (text || "").trim();
  if (!t) return [];
  // підтримка: нові рядки або " • " або "- "
  const byLines = t.split(/\r?\n+/).map((s) => s.trim()).filter(Boolean);
  if (byLines.length > 1) return byLines;

  // якщо все в один рядок з маркерами
  const byBullets = t
    .split(/(?:\s*•\s*|\s*-\s+)/g)
    .map((s) => s.trim())
    .filter(Boolean);

  return byBullets.length > 1 ? byBullets : [t];
}

export async function buildArtistProfilePdf(opts: {
  jobTitle: string;
  companyName?: string | null;
  artist: {
    full_name: string;
    country?: string;
    date_of_birth: string;
    height?: string;
    weight?: string;
    experience?: string;
    biography?: string;
    picture?: string;
  };
  cover_message?: string;
  promo_url?: string;
  photos?: File[]; // up to 5 (поки не використовуємо тут)
}) {
  const { jobTitle, companyName, artist, cover_message } = opts;

  // Fonts
  const fontRegularBytes = await readPublic("fonts/Montserrat-VariableFont_wght.ttf");
  const fontBoldBytes = await readPublic("fonts/Montserrat-Bold.ttf");

  const pdfDoc = await PDFDocument.create();
  pdfDoc.registerFontkit(fontkit);

  const fontRegular = await pdfDoc.embedFont(fontRegularBytes);
  const fontBold = await pdfDoc.embedFont(fontBoldBytes);

  const createPage = () => {
    const page = pdfDoc.addPage(A4);
    const { width, height } = page.getSize();

    page.drawRectangle({ x: 0, y: 0, width, height, color: BRAND.white });
    drawHeader({ page, width, height, fontBold });
    drawFooter({ page, fontRegular });

    return { page, width, height };
  };

  let { page, width, height } = createPage();

  const ensureSpace = (y: number, needed: number) => {
    const minY = M.bottom + 40; // safe area above footer
    if (y - needed >= minY) return { page, width, height, y };

    // new page
    ({ page, width, height } = createPage());
    // content top start (below header + title area)
    const freshY = height - 120;
    return { page, width, height, y: freshY };
  };

  // Title block
  let y = height - 120;

  page.drawText("Application for", { x: M.left, y, size: 10, font: fontBold, color: BRAND.muted });
  y -= 22;

  page.drawText(jobTitle || "—", { x: M.left, y, size: 16, font: fontRegular, color: BRAND.primary });
  y -= 22;

  if (companyName) {
    page.drawText(companyName, { x: M.left, y, size: 10, font: fontRegular, color: BRAND.muted });
    y -= 28;
  }

  // Two columns (Profile details + Photo)
  const gap = 18;
  const leftW = (width - M.left - M.right - gap) * 0.58;
  const rightW = (width - M.left - M.right - gap) * 0.42;
  const leftX = M.left;
  const rightX = leftX + leftW + gap;

  let yl = y;
  let yr = y;

  // Left: Profile details only
  page.drawText("Profile", { x: leftX, y: yl, size: H2, font: fontBold, color: BRAND.accent2 });
  yl -= 16;

  const rows: Array<[string, string]> = [
    ["Full name", safe(artist.full_name) || "—"],
    ["Country", safe(artist.country) || "—"],
    ["Date of birth", safe(normalizeDateString(artist.date_of_birth)) || "—"],
    ["Height (cm)", safe(artist.height) || "—"],
    ["Weight (kg)", safe(artist.weight) || "—"],
  ];

  for (const [k, v] of rows) {
    page.drawText(k, { x: leftX, y: yl, size: 9, font: fontBold, color: BRAND.muted });
    yl -= 14;

    const lines = wrapText(v || "—", leftW, fontRegular, 11);
    for (const ln of lines) {
      page.drawText(ln, { x: leftX, y: yl, size: 11, font: fontRegular, color: BRAND.primary });
      yl -= LH(11);
    }
    yl -= 10;
  }

  // Right: profile photo only
  page.drawText("Photo", { x: rightX, y: yr, size: H2, font: fontBold, color: BRAND.accent2 });
  yr -= 16;

  const boxW = rightW;
  const boxH = 220;

  const rawProfileBytes = artist.picture ? await loadImageBytes(artist.picture) : null;
  const profileBytes = rawProfileBytes ? (await normalizeToJpeg(rawProfileBytes)) ?? rawProfileBytes : null;

  if (profileBytes?.length) {
    const img = await pdfDoc.embedJpg(profileBytes);

    const pad = 8;
    const availW = boxW - pad * 2;
    const availH = boxH - pad * 2;

    const ratio = Math.min(availW / img.width, availH / img.height);
    const iw = img.width * ratio;
    const ih = img.height * ratio;

    const ix = rightX;
    const iy = (yr - boxH) + (boxH - ih) / 2;

    page.drawImage(img, { x: ix, y: iy, width: iw, height: ih });
  } else {
    page.drawText("No profile photo", {
      x: rightX + 12,
      y: yr - 20,
      size: 9,
      font: fontRegular,
      color: BRAND.muted,
    });
  }

  yr -= boxH + 18;

  // ===== Full-width content (Experience / Biography / Message) =====
  const fullX = M.left;
  const fullW = width - M.left - M.right;

  // start below the lower column
  let yFull = Math.min(yl, yr) - 8;

  // subtle divider
  ({ page, width, height, y: yFull } = ensureSpace(yFull, 30));
  page.drawRectangle({ x: fullX, y: yFull, width: fullW, height: 1, color: BRAND.bg });
  yFull -= 18;

  // Experience (full width) — як список, якщо є маркери/нові рядки
  ({ page, width, height, y: yFull } = ensureSpace(yFull, 60));
  yFull = drawSectionTitle(page, "Experience", fullX, yFull, fontBold);

  const expItems = splitBullets(safe(artist.experience));
  if (expItems.length > 1) {
    for (const item of expItems) {
      // оцінка простору на 2 рядки
      ({ page, width, height, y: yFull } = ensureSpace(yFull, LH(BODY) * 2 + 6));
      yFull = drawWrappedBlock({
        page,
        text: `• ${item}`,
        x: fullX,
        y: yFull,
        width: fullW,
        font: fontRegular,
        fontSize: BODY,
        lineHeight: LH(BODY),
      });
      yFull -= 4;
    }
  } else {
    ({ page, width, height, y: yFull } = ensureSpace(yFull, 120));
    yFull = drawWrappedBlock({
      page,
      text: safe(artist.experience) || "—",
      x: fullX,
      y: yFull,
      width: fullW,
      font: fontRegular,
      fontSize: BODY,
      lineHeight: LH(BODY),
    });
  }

  yFull -= 14;

  // Biography (full width)
  if ((artist.biography || "").trim()) {
    ({ page, width, height, y: yFull } = ensureSpace(yFull, 60));
    yFull = drawSectionTitle(page, "Biography", fullX, yFull, fontBold);

    // для довгих біографій краще щільніше міжряддя
    ({ page, width, height, y: yFull } = ensureSpace(yFull, 120));
    yFull = drawWrappedBlock({
      page,
      text: safe(artist.biography) || "—",
      x: fullX,
      y: yFull,
      width: fullW,
      font: fontRegular,
      fontSize: BODY,
      lineHeight: LH(BODY),
    });

    yFull -= 14;
  }

  // Message (full width)
  if (cover_message && cover_message.trim()) {
    ({ page, width, height, y: yFull } = ensureSpace(yFull, 60));
    yFull = drawSectionTitle(page, "Message", fullX, yFull, fontBold);

    ({ page, width, height, y: yFull } = ensureSpace(yFull, 120));
    yFull = drawWrappedBlock({
      page,
      text: cover_message.trim(),
      x: fullX,
      y: yFull,
      width: fullW,
      font: fontRegular,
      fontSize: 9,
      lineHeight: LH(9),
    });

    yFull -= 10;
  }

  const bytes = await pdfDoc.save();
  return Buffer.from(bytes);
}
